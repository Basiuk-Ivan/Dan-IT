/* 
1. Поясніть своїми словами, як ви розумієте, як працює прототипне наслідування в Javascript?

Доволі часто нам потрібно доповнити або розширити наш поточний обʼєкт. Наприклад, у нас є обʼєкт User з його властивостями і методами. І ми хочемо створити новий обʼєкт Admin, який буде трішки відрізнятись від основного User. Тобто ми хочемо повторно використати те, що є у User, але і додати якісь свої властивості. 

let user = {
    name: 'ivan',
    age: 25,
};

let admin = {
    __proto__: user,
    city: 'Kyiv',
};

Властивість __proto__: user; - дозволяє нам успадкувати властивості user. І таким чином ми також можемо їх використовувати. Прототипом обʼєкта admin виступає обʼєкт user.


2. Для чого потрібно викликати super() у конструкторі класу-нащадка? 

Коли звичайна функція виконується зі словом new, вона створює порожній об’єкт і присвоює йому this.
Але коли викликається похідний конструктор, він цього не робить. Він очікує, що батьківський конструктор зробить це.
Таким чином, в похідному конструкторі потрібно викликати super(), щоб виконати його батьківський конструктор, інакше об’єкт для this не буде створено. І ми отримаємо помилку.
*/

const employee = new Employee('Ivan', 25, 1500);

console.log(employee);

// ============================================ //

const programmerFirst = new Programmer('Alex', 24, 1000, ['Ukrainian,', 'Polish', 'English']);
const programmerSecond = new Programmer('Bogdan', 25, 1200, ['China', 'Indian']);
const programmerThird = new Programmer('Vasya', 26, 1400, ['French', 'Italian']);

console.log(programmerFirst);
console.log(programmerSecond);
console.log(programmerThird);

console.log(programmerFirst.getSalary());
